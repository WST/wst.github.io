<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ilya Averkov</title>
  
  <!-- Favicon and app icons -->
  <link rel="icon" type="image/png" sizes="32x32" href="/static/icon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/static/icon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/static/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="192x192" href="/static/android-chrome-192x192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="/static/android-chrome-512x512.png">
  <link rel="manifest" href="/static/site.webmanifest">
  <meta name="theme-color" content="#000000">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Fira+Mono:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #000;
      --fg: #c8facc;
      --dim: #0c2b0f;
      --grid: #0c4018;
      --accent: #9affb3;
      --shadow: rgba(0, 0, 0, .75);
    }

    html, body {
      height: 100%;
      background: var(--bg);
      color: var(--fg);
      margin: 0;
      font-family: 'Fira Mono', 'Fira Code', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      letter-spacing: 0.5px;
      overflow: hidden;
    }

    /* background game canvas (very subtle) */
    #bg {
      position: fixed;
      inset: 0;
      z-index: 0;
      opacity: .12;              /* keep it dim */
      filter: blur(.25px) saturate(70%);
      image-rendering: pixelated; /* crispy grid */
      pointer-events: none;
      will-change: transform;
      transform: translateZ(0); /* force GPU acceleration */
    }

    body::before,
    body::after {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
    }

    /* faint network motif */
    body::before {
      background:
        radial-gradient(circle at 25% 20%, var(--grid) 1px, transparent 1px) 0 0/40px 40px,
        radial-gradient(circle at 75% 60%, var(--grid) 1px, transparent 1px) 0 0/40px 40px,
        radial-gradient(circle at 15% 80%, var(--grid) 1px, transparent 1px) 0 0/40px 40px,
        radial-gradient(circle at 55% 10%, var(--grid) 1px, transparent 1px) 0 0/40px 40px;
      opacity: .35;
      filter: blur(.2px);
    }

    .grid {
      position: fixed;
      inset: 0;
      background:
        repeating-linear-gradient(120deg, transparent 0 40px, color-mix(in oklch, var(--grid), transparent 60%) 40px 41px),
        repeating-linear-gradient(60deg, transparent 0 40px, color-mix(in oklch, var(--grid), transparent 60%) 40px 41px);
      mask: radial-gradient(80% 80% at 50% 50%, #000 60%, transparent 100%);
      opacity: .18;
      z-index: 0; /* above game but below content */
    }

    @media (prefers-reduced-motion: no-preference) {
      body::after {
        background: linear-gradient(transparent 95%, rgba(0,0,0,.25) 95%);
        background-size: 100% 3px;
        mix-blend-mode: overlay;
        animation: buzz 8s linear infinite;
        opacity: .6;
      }
      @keyframes buzz { to { transform: translateY(3px); } }
    }

    .wrap {
      position: relative;
      z-index: 1;
      display: grid;
      place-items: center;
      height: 100%;
      padding: 3rem 1rem;
      text-align: center;
    }

    .profile-photo {
      margin: 0 auto 2rem auto;
      width: 220px;
      height: 220px;
      border-radius: 50%;
      overflow: hidden;
      background: var(--bg);
    }

    .profile-photo img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      object-position: center;
    }

    h1 {
      font-weight: 700;
      font-size: clamp(32px, 6vw, 72px);
      margin: 0 0 1.2rem 0;
      text-shadow: 0 0 12px color-mix(in oklch, var(--accent), transparent 70%), 0 0 32px rgba(0,255,128,.15);
      display: block;
      position: relative;
    }

    h1::after {
      content: "_";
      display: inline-block;
      margin-left: 6px;
      animation: cursorBlink 2s ease-in-out infinite;
      width: 0;
      overflow: visible;
    }
    
    @keyframes cursorBlink {
      0% { opacity: 0.15; }
      25% { opacity: 0.9; }
      50% { opacity: 0.15; }
      75% { opacity: 0.9; }
      100% { opacity: 0.15; }
    }

    .subtitle {
      font-size: clamp(16px, 3vw, 24px);
      margin: 0 0 1.5rem 0;
      opacity: 0.8;
      font-weight: 400;
      letter-spacing: 0.3px;
      line-height: 2.3rem;
    }

    .social-section {
      margin-top: 3.5rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    .social-links {
      display: flex;
      gap: 1.5rem;
      align-items: center;
    }

    .location {
      font-size: clamp(10px, 1.8vw, 12px);
      opacity: 0.7;
      font-weight: 400;
    }

    .social-link {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      color: var(--accent);
      text-decoration: none;
      font-size: clamp(14px, 2.5vw, 16px);
      padding: 0.4rem 0.8rem;
      border-radius: 0.3rem;
      border: 1px solid transparent;
      transition: all 0.2s ease;
      opacity: 0.8;
    }

    .social-link:hover {
      opacity: 1;
      border-color: var(--accent);
      background: rgba(154, 255, 179, 0.1);
      transform: translateY(-1px);
    }

    .social-icon {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
    }

    /* === Console-style skill line === */
    .skill-line {
      margin-top: 1.5rem;
      display: inline-block;
      padding: .6rem .9rem;
      border-radius: .5rem;
      border: 1px dashed #0e3b19;
      background: linear-gradient(#031507, #020a05);
      box-shadow: 0 10px 40px var(--shadow), inset 0 0 40px rgba(0,255,128,.05);
      position: relative;
      line-height: 1;
    }

    .skill-line::before { /* fake prompt */
      content: "$ skills:";
      color: color-mix(in oklch, var(--fg), #6aff90 25%);
      margin-right: .65rem;
      opacity: .9;
    }

    /* Hide skills prefix on mobile devices */
    @media (max-width: 768px) {
      .skill-line::before {
        content: "";
        margin-right: 0;
      }
    }

    /* Adaptive spacing for small screens */
    @media (max-height: 800px) {
      .wrap {
        padding: 2rem 1rem;
      }
      .profile-photo {
        margin-bottom: 1.5rem;
      }
      .subtitle {
        margin-bottom: 1rem;
      }
      .skill-line {
        margin-top: 1rem;
      }
      .social-section { 
        margin-top: 1.5rem;
      }
      .foot { 
        bottom: 0.5rem;
        display: none;
      }
    }

    /* Even more compact for very small screens */
    @media (max-height: 750px) {
      .wrap {
        padding: 1.5rem 1rem;
      }
      .profile-photo {
        margin-bottom: 1rem;
      }
      .subtitle {
        margin-bottom: 0.8rem;
      }
      .skill-line {
        margin-top: 0.8rem;
      }
      .social-section { 
        margin-top: 1rem; 
      }
      .foot { 
        bottom: 0.25rem; 
      }
    }

    #skillword {
      display: inline-flex;
      gap: .06em;
      vertical-align: baseline;
    }

    .glyph {
      min-width: .62em;
      display: inline-block;
      text-transform: uppercase;
      color: var(--accent);
      text-shadow: 0 0 10px rgba(0,255,128,.18);
      will-change: contents, filter;
      font-size: 1.2em;
    }

    /* caret for the skill line */
    .caret { display: none; }

    /* Footer */
    .foot {
      position: fixed;
      bottom: .75rem; left: 0; right: 0;
      text-align: center;
      font-size: 12px;
      opacity: .65;
      user-select: none;
      letter-spacing: .1em;
      font-family: 'Fira Mono', 'Fira Code', ui-monospace, monospace;
      white-space: pre;
      z-index: 1;
    }

    .ping-dot {
      display: inline-block;
      width: 6px;
      height: 6px;
      background: var(--accent);
      border-radius: 50%;
      margin-left: 4px;
      animation: blinkPing 1s infinite;
    }

    @keyframes blinkPing { 0%, 80%, 100% { opacity: 0; } 40% { opacity: 1; } }
  </style>
</head>
<body>
  <canvas id="bg" aria-hidden="true"></canvas>
  <div class="grid" aria-hidden="true"></div>
  <div class="wrap">
    <main>
      <div class="profile-photo">
        <img src="/static/images/me.jpg" alt="Ilya Averkov" loading="lazy">
      </div>
      <h1>Ilya Averkov</h1>

      <p class="subtitle">Backend developer. DevOps engineer. Network administrator.<br/>Currently not available for hire.</p>

      <!-- Console-like animated skill line -->
      <div class="skill-line" role="img" aria-label="–ù–∞–≤—ã–∫–∏: –∫–æ–Ω—Å–æ–ª—å–Ω–∞—è —Å—Ç—Ä–æ–∫–∞">
        <span id="skillword" aria-hidden="false"></span>
        <span class="caret" aria-hidden="true"></span>
      </div>

      <div class="social-section">
        <div class="social-links">
          <a href="https://github.com/WST" target="_blank" rel="noopener noreferrer" class="social-link">
            <svg class="social-icon" viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
              <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
            </svg>
            GitHub
          </a>
          <a href="https://www.youtube.com/@ilya.averkov" target="_blank" rel="noopener noreferrer" class="social-link">
            <svg class="social-icon" viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
              <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
            </svg>
            YouTube
          </a>
          <a href="https://averkov.net/docs/" target="_blank" rel="noopener noreferrer" class="social-link">
            <svg class="social-icon" viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
              <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6z"/>
              <path d="M14 2v6h6"/>
              <path d="M16 13H8"/>
              <path d="M16 17H8"/>
              <path d="M10 9H8"/>
            </svg>
            Docs
          </a>
        </div>
        
        <span class="location">üìç Vanadzor, Armenia</span>
      </div>
    </main>
  </div>

  <div class="foot" aria-hidden="true">/* route add default 10.0.0.1; ping -i 5 world <span class="ping-dot"></span> */</div>

  <script>
    // === CONFIG ===
    const TAGS = [
      "HTML", "CSS", "PHP", "Python", "C", "C++", "JavaScript", "bash", "Git", "Subversion", "Github", "Redmine", "Gitlab", "gitlab-runner", "CMake", "CPack", "uWSGI", "nginx", "Apache", "PHP-FPM", "Composer", "PEAR", "PECL", "PHP-FIG", "PHPUnit", "Psalm", "Twig", "GuzzleHttp", "Django", "Django REST Framework", "Django Crispy Forms", "Django Grappelli", "Jinja2", "MySQL", "SQLite", "MongoDB", "Lektor", "sphinx-doc", "syslog-ng", "XML", "DOM", "expat", "XMPP", "ejabberd", "Prosody", "Openfire", "XEP-0114", "mcabber", "qxmpp", "libgloox", "RSS", "GeoIP", "Linux", "FreeBSD", "NetBSD", "OpenVZ", "Virtuozzo 7", "Docker", "docker-compose", "nmap", "libpcap", "NetFlow", "SNMP", "BGP", "UTM5", "RADIUS", "rrdtool", "MikroTik", "RouterOS", "Postfix", "Dovecot", "Roundcube", "ClamAV", "SpamAssassin", "Bind9", "PowerDNS", "PowerDNS Recursor", "iptables", "ebtables", "iproute2", "bridge-utils", "tcptraceroute", "qemu-kvm", "libvirt", "VMmanager", "DHCP", "IPMI", "IPv6", "IPv6 NDP", "NFS", "epoll", "libmaycloud", "SOAP", "python-lxml", "python-requests", "Firezone", "Outline", "Flussonic", "ffmpeg", "systemd", "sysvinit", "ssh", "scp", "Raspbian", "Armbian", "Midnight Commander", "links", "GIMP", "Sublime Text", "Visual Studio Code", "Cursor", "ChatGPT", "DipTrace", "nasi goreng", "operational amplifiers", "Microcontrollers", "Film dev (D-76, C-41)", "Darkroom printing", "Silines RODOS relays", "pdftk", "–ö574–£–î1–ê audio", "PhpStorm", "CLion", "PyCharm", "Psi+", "DataGrip", "Sun Fire"
    ];
    const INTERVAL_MS = 5000; // 5 seconds

    // Glyph set for scrambling (mix of hex, symbols, ASCII)
    const GLYPHS = "0123456789ABCDEF/*.-_|#@$%&+<>[]{}~".split("");

    const REDUCED = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    const maxLen = TAGS.reduce((m, s) => Math.max(m, s.length), 0);
    const wordEl = document.getElementById('skillword');

    // Create fixed number of glyph spans
    const spans = [];
    for (let i = 0; i < maxLen; i++) {
      const s = document.createElement('span');
      s.className = 'glyph';
      s.textContent = ' ';
      wordEl.appendChild(s);
      spans.push(s);
    }

    function padUpper(word) {
      return word.toUpperCase().padEnd(maxLen, ' ');
    }

    function randomGlyph() {
      return GLYPHS[(Math.random() * GLYPHS.length) | 0];
    }

    // Per-letter scramble animation to a target word
    function animateTo(word) {
      const target = padUpper(word);

      // Respect reduced motion
      if (REDUCED) {
        for (let i = 0; i < maxLen; i++) spans[i].textContent = target[i];
        trimInvisible(word.length);
        return;
      }

      const now = performance.now();
      // letter-by-letter stagger
      const baseDelay = 30;               // ms between glyph frames
      const perLetterStagger = 35;        // ms between letters starting
      const minFlips = 6, maxFlips = 14;  // how many random frames before landing

      spans.forEach((span, i) => {
        const ch = target[i];
        const flips = (Math.random() * (maxFlips - minFlips) + minFlips) | 0;
        const startAt = now + i * perLetterStagger;

        let frame = 0;
        function tick(t) {
          if (t < startAt) { requestAnimationFrame(tick); return; }
          if (frame < flips) {
            span.textContent = randomGlyph();
            // subtle flash for the active cell
            span.style.filter = 'brightness(1.6)';
            setTimeout(() => span.style.filter = '', baseDelay);
            frame++;
            setTimeout(() => requestAnimationFrame(tick), baseDelay);
          } else {
            span.textContent = ch;
          }
        }
        requestAnimationFrame(tick);
      });

      trimInvisible(word.length);
    }

    // Hide extra cells so the line width matches the current word
    function trimInvisible(len) {
      spans.forEach((s, i) => s.style.display = i < len ? 'inline-block' : 'none');
    }

    // Boot
    function shuffle(array){
      for (let i=array.length-1; i>0; i--){
        const j = (Math.random()*(i+1))|0;
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    let order = shuffle([...Array(TAGS.length).keys()]);
    let pointer = 0;
    let lastShown = null;

    function nextTagIndex(){
      if (pointer >= order.length){
        order = shuffle(order);
        pointer = 0;
        // avoid immediate repeat across reshuffle boundaries
        if (lastShown !== null && order.length > 1 && order[0] === lastShown){
          const j = 1 + ((Math.random()*(order.length-1))|0);
          [order[0], order[j]] = [order[j], order[0]];
        }
      }
      const idx = order[pointer++];
      lastShown = idx;
      return idx;
    }

    let idx = nextTagIndex();
    animateTo(TAGS[idx]);

    setInterval(() => {
      idx = nextTagIndex();
      animateTo(TAGS[idx]);
    }, INTERVAL_MS);

    // ======= SUBTLE BACKGROUND GAME (Snake or Game of Life) =======
    ;(function(){
      const canvas = document.getElementById('bg');
      const ctx = canvas.getContext('2d');
      const prefersReduce = REDUCED; // reuse

      let W, H, COLS, ROWS, CELL;
      function resize(){
        W = canvas.width = innerWidth;
        H = canvas.height = innerHeight;
        // choose a cell size that yields ~80-120 columns, accounting for device pixel ratio
        const dpr = window.devicePixelRatio || 1;
        const baseCellSize = Math.max(6, Math.floor(Math.min(W, H) / 90));
        CELL = Math.max(baseCellSize, Math.floor(baseCellSize * Math.min(dpr, 2))); // cap at 2x to avoid too large cells
        COLS = Math.floor(W / CELL);
        ROWS = Math.floor(H / CELL);
      }
      addEventListener('resize', resize, {passive:true});
      resize();

      // shared draw util
      function drawCell(x, y, v){
        if (!v) return;
        const px = x * CELL, py = y * CELL;
        // soft glow rectangles
        ctx.fillStyle = 'rgba(154,255,179,0.9)';
        ctx.fillRect(px, py, CELL, CELL);
        ctx.fillStyle = 'rgba(0,0,0,0.85)';
        ctx.fillRect(px+1, py+1, Math.max(1,CELL-2), Math.max(1,CELL-2));
        ctx.fillStyle = 'rgba(154,255,179,0.25)';
        ctx.fillRect(px+1, py+1, Math.max(1,CELL-2), Math.max(1,CELL-2));
      }

      // game state management
      let GAME = 'snake'; // always start with snake
      let gameStartTime = performance.now();
      const LIFE_DURATION = 1 * 60 * 1000; // 1 minute in milliseconds
      const MATRIX_DURATION = 1 * 60 * 1000; // 1 minute in milliseconds

      // ===== Conway's Game of Life =====
      let a,b;
      function lifeInit(){
        a = new Uint8Array(COLS*ROWS);
        for (let i=0;i<a.length;i++) a[i] = Math.random()<0.18?1:0;
      }
      function lifeStep(){
        b = new Uint8Array(COLS*ROWS);
        const w = COLS, h = ROWS;
        for (let y=0;y<h;y++){
          for (let x=0;x<w;x++){
            const i = y*w+x;
            let n=0;
            for (let dy=-1;dy<=1;dy++){
              for (let dx=-1;dx<=1;dx++){
                if (dx===0&&dy===0) continue;
                const nx=(x+dx+w)%w, ny=(y+dy+h)%h;
                n += a[ny*w+nx];
              }
            }
            const alive = a[i];
            b[i] = (alive && (n===2||n===3)) || (!alive && n===3) ? 1:0;
          }
        }
        a = b;
      }
      function lifeDraw(){
        ctx.clearRect(0,0,W,H);
        for (let y=0;y<ROWS;y++){
          for (let x=0;x<COLS;x++){
            drawCell(x,y,a[y*COLS+x]);
          }
        }
      }

      // ===== Snake (autonomous) =====
      let snake, dir, food, snakeGrid;
      function snakeInit(){
        snakeGrid = new Uint8Array(COLS*ROWS);
        const midx = (COLS/2)|0, midy = (ROWS/2)|0;
        snake = [{x:midx,y:midy}];
        dir = {x:1,y:0};
        placeFood();
      }
      function placeFood(){
        let x,y,tries=0;
        do { x=(Math.random()*COLS)|0; y=(Math.random()*ROWS)|0; tries++; }
        while (occupies(x,y) && tries<1000);
        food = {x,y};
      }
      function occupies(x,y){
        for (let i=0;i<snake.length;i++) if (snake[i].x===x && snake[i].y===y) return true;
        return false;
      }
      function snakeStep(){
        // very simple AI: try to go toward food; avoid immediate self-collision
        function turnLeft(d){ return {x:-d.y,y:d.x}; }
        function turnRight(d){ return {x:d.y,y:-d.x}; }
        function forward(p,d){ return {x:(p.x+d.x+COLS)%COLS,y:(p.y+d.y+ROWS)%ROWS}; }
        const head = snake[0];
        const forwardPos = forward(head,dir);
        const leftPos = forward(head,turnLeft(dir));
        const rightPos = forward(head,turnRight(dir));
        function safe(pos){ return !occupies(pos.x,pos.y); }
        // greedy toward food with fallback
        const dx = (food.x - head.x + COLS) % COLS; const dy = (food.y - head.y + ROWS) % ROWS;
        const preferX = (dx>COLS/2? -1: 1)* (dx===0?0:1);
        const preferY = (dy>ROWS/2? -1: 1)* (dy===0?0:1);
        const options = [];
        // rank directions: toward food axes first
        const cand = [
          {d:dir, p:forwardPos, score: (preferX*dir.x + preferY*dir.y)},
          {d:turnLeft(dir), p:leftPos, score: (preferX*turnLeft(dir).x + preferY*turnLeft(dir).y)},
          {d:turnRight(dir), p:rightPos, score: (preferX*turnRight(dir).x + preferY*turnRight(dir).y)}
        ].sort((A,B)=>B.score-A.score);
        let chosen = cand.find(c=>safe(c.p)) || cand[0];
        dir = chosen.d;
        const newHead = chosen.p;

        // Check for collision with self
        if (occupies(newHead.x, newHead.y)) {
          // Game over - switch to life
          GAME = 'life';
          gameStartTime = performance.now();
          lifeInit();
          return;
        }
        
        snake.unshift(newHead);
        if (newHead.x===food.x && newHead.y===food.y){
          placeFood();
        } else {
          snake.pop();
        }
      }
      function snakeDraw(){
        ctx.clearRect(0,0,W,H);
        // food
        drawCell(food.x, food.y, 1);
        // snake body (same brightness as life)
        for (let i=snake.length-1;i>=0;i--){
          const p = snake[i];
          const px = p.x*CELL, py = p.y*CELL;
          ctx.fillStyle = 'rgba(154,255,179,0.9)';
          ctx.fillRect(px,py,CELL,CELL);
          ctx.fillStyle = 'rgba(0,0,0,0.85)';
          ctx.fillRect(px+1,py+1,Math.max(1,CELL-2),Math.max(1,CELL-2));
          ctx.fillStyle = 'rgba(154,255,179,0.25)';
          ctx.fillRect(px+1,py+1,Math.max(1,CELL-2),Math.max(1,CELL-2));
        }
      }

      // ===== Matrix Rain Effect =====
      let matrixDrops = [];
      function matrixInit(){
        matrixDrops = [];
        // Create drops for each column
        for (let x = 0; x < COLS; x++) {
          matrixDrops.push({
            x: x,
            y: Math.random() * ROWS,
            speed: 0.5 + Math.random() * 1.5,
            length: 3 + Math.floor(Math.random() * Math.min(27, ROWS - 3)),
            opacity: 0.6 + Math.random() * 0.4
          });
        }
      }
      function matrixStep(){
        // Update drops
        for (let i = 0; i < matrixDrops.length; i++) {
          const drop = matrixDrops[i];
          drop.y += drop.speed;
          
          // Reset drop when it goes off screen
          if (drop.y > ROWS + drop.length) {
            drop.y = -drop.length;
            drop.x = Math.floor(Math.random() * COLS);
            drop.speed = 0.5 + Math.random() * 1.5;
            drop.length = 3 + Math.floor(Math.random() * Math.min(27, ROWS - 3));
            drop.opacity = 0.6 + Math.random() * 0.4;
          }
        }
      }
      function matrixDraw(){
        ctx.clearRect(0,0,W,H);
        
        // Draw drops
        for (let i = 0; i < matrixDrops.length; i++) {
          const drop = matrixDrops[i];
          
          // Draw drop trail
          for (let j = 0; j < drop.length; j++) {
            const y = Math.floor(drop.y - j);
            if (y >= 0 && y < ROWS) {
              const px = drop.x * CELL;
              const py = y * CELL;
              const fade = 1 - (j / drop.length);
              const alpha = drop.opacity * fade;
              
              // Brighter matrix cells
              ctx.fillStyle = `rgba(154,255,179,${alpha * 1.5})`;
              ctx.fillRect(px, py, CELL, CELL);
              ctx.fillStyle = 'rgba(0,0,0,0.85)';
              ctx.fillRect(px+1, py+1, Math.max(1,CELL-2), Math.max(1,CELL-2));
              ctx.fillStyle = `rgba(154,255,179,${alpha * 0.8})`;
              ctx.fillRect(px+1, py+1, Math.max(1,CELL-2), Math.max(1,CELL-2));
            }
          }
        }
      }

      // orchestrate with performance optimization
      let last=0, acc=0, frameCount=0, lastFPS=0;
      let interval = prefersReduce ? 1000 : 120; // ms per frame
      
      // Adaptive frame rate for mobile devices
      if (window.innerWidth <= 768 || /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        interval = Math.max(interval, 200); // slower on mobile
      }
      
      function loop(ts){
        if (!last) last = ts;
        const dt = ts - last; last = ts; acc += dt;
        frameCount++;
        
        // Calculate FPS every second
        if (ts - lastFPS >= 1000) {
          const fps = frameCount;
          frameCount = 0;
          lastFPS = ts;
          
          // Adaptive interval based on performance
          if (fps < 30 && interval < 300) {
            interval += 20; // slow down if FPS is low
          } else if (fps > 50 && interval > 80) {
            interval -= 10; // speed up if FPS is high
          }
        }
        
        // Check if it's time to switch games
        const elapsed = performance.now() - gameStartTime;
        
        if (GAME === 'life' && elapsed > LIFE_DURATION) {
          GAME = 'matrix';
          gameStartTime = performance.now();
          matrixInit();
        } else if (GAME === 'matrix' && elapsed > MATRIX_DURATION) {
          GAME = 'snake';
          gameStartTime = performance.now();
          snakeInit();
        }
        
        if (acc >= interval){
          acc = 0;
          if (GAME==='life') { lifeStep(); lifeDraw(); }
          else if (GAME==='matrix') { matrixStep(); matrixDraw(); }
          else { snakeStep(); snakeDraw(); }
        }
        requestAnimationFrame(loop);
      }

      function boot(){
        gameStartTime = performance.now();
        if (GAME==='life') lifeInit(); 
        else if (GAME==='matrix') matrixInit();
        else snakeInit();
        // draw first frame
        if (GAME==='life') lifeDraw(); 
        else if (GAME==='matrix') matrixDraw();
        else snakeDraw();
        requestAnimationFrame(loop);
      }

      // reinit on resize to keep grid crisp
      let resizeTO;
      addEventListener('resize', ()=>{
        clearTimeout(resizeTO);
        resizeTO = setTimeout(()=>{
          if (GAME==='life') lifeInit(); 
          else if (GAME==='matrix') matrixInit();
          else snakeInit();
        }, 150);
      });

      boot();
    })();
  </script>
</body>
</html>
